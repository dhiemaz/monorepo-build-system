plugins {
    id 'java'
    id 'war'
    id 'org.springframework.boot' version '3.4.2'
    id 'io.spring.dependency-management' version '1.1.7'
}

// Konfigurasi untuk semua project
allprojects {
    group = 'com.app.service'
    version = '0.0.1'

    repositories {
        mavenCentral()
    }
}

// Konfigurasi khusus untuk subproject
subprojects {
    apply plugin: 'java'
}

// Konfigurasi Java toolchain
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

bootJar { enabled = false }
bootWar { enabled = false }

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.boot:spring-boot-starter-data-redis-reactive'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    developmentOnly 'org.springframework.boot:spring-boot-docker-compose'
    runtimeOnly 'org.postgresql:postgresql'
    annotationProcessor 'org.projectlombok:lombok'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'io.projectreactor:reactor-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
    useJUnitPlatform()
}

def subProjects = ['catalog', 'member', 'transaction', 'payment']

subProjects.each { service ->
    tasks.register(service) {
        dependsOn ":${service}:build"
    }
}

def requestedTasks = gradle.startParameter.taskNames

tasks.register("buildServices") {
    group = "build"
    dependsOn(":catalog:build", ":member:build", ":transaction:build", ":payment:build")
}

tasks.register("builds") {
    group = "build"

    if (requestedTasks.size() > 1) {
        subprojects { proj ->
            if (!requestedTasks.contains(proj.name)) {
                tasks.matching { it.name == 'build' }.all { task ->
                    task.enabled = false
                }
            }
        }        
    } 
}


import java.nio.file.*

// File untuk menyimpan PID service yang berjalan
def pidFile = file("$buildDir/service-pids.txt")

// Ambil daftar task yang diminta, kecuali 'runs'
def requestedServices = gradle.startParameter.taskNames.findAll { it != "runs" }

tasks.register("runs") {
    group = "application"
    description = "Runs specified services in parallel in the foreground."

    doFirst {
        if (requestedServices.isEmpty()) {
            throw new GradleException("‚ùå Please specify service names after runs, e.g. gradle runs catalog or gradle runs catalog payment")
        }
        
        // Nonaktifkan task build pada subproject yang tidak termasuk dalam daftar requestedServices.
        subprojects { proj ->
            if (!requestedServices.contains(proj.name)) {
                proj.tasks.matching { it.name == 'build' }.configureEach { task ->
                    task.enabled = false
                }
            }
        }
    }

    doLast {
        // Cari subproject yang sesuai dengan nama yang diminta.
        def serviceProjects = subprojects.findAll { requestedServices.contains(it.name) }
        if (serviceProjects.isEmpty()) {
            throw new GradleException("‚ùå No valid services found. Available: ${subprojects*.name}")
        }
        
        println "üöÄ Running services: ${requestedServices.join(', ')}"

        // def pidFile = file("$buildDir/service-pids.txt")
        pidFile.text = "" // Clear previous PIDs

        serviceProjects.each { serviceProject ->
            def serviceName = serviceProject.name
            println "‚ñ∂Ô∏è Starting ${serviceName} in foreground..."

            def process = new ProcessBuilder("./gradlew", ":${serviceName}:bootRun")
                .redirectErrorStream(true)
                .inheritIO()
                .start()

            // Simpan PID untuk penghentian nanti
            def pid = process.toHandle().pid()
            println "‚úÖ ${serviceName} started with PID: $pid"
            pidFile.append("$pid\n")
        }
    }
}


// Task to stop running services
tasks.register("stop") {
    description = "Stops all running services started by runServices."
    group = "application"

    doLast {
        if (!pidFile.exists() || pidFile.text.trim().isEmpty()) {
            println "‚ö†Ô∏è No running services found."
            return
        }

        def pids = pidFile.readLines()
        pids.each { pid ->
            println "‚õî Stopping service with PID: $pid"
            try {
                ProcessHandle.of(Long.parseLong(pid)).ifPresent { handle ->
                    handle.destroy()
                    println "‚úÖ Stopped process $pid"
                }
            } catch (Exception e) {
                println "‚ö†Ô∏è Could not stop process $pid: ${e.message}"
            }
        }

        // Clear PID file after stopping
        pidFile.text = ""
    }
}


